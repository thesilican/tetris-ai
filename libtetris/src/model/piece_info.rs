use crate::PieceType;

/// Static information about each shape
pub struct PieceInfo;

impl PieceInfo {
    /// The initial coordinates for each piece
    pub fn spawn_location(piece_type: PieceType) -> (i8, i8) {
        match piece_type {
            PieceType::O
            | PieceType::T
            | PieceType::L
            | PieceType::J
            | PieceType::S
            | PieceType::Z => (3, 20),
            PieceType::I => (3, 19),
        }
    }

    /// The shape of each piece, as a 2d array of bools
    pub fn shape(piece_type: PieceType, rotation: i8) -> [[bool; 4]; 4] {
        const X: bool = true;
        const O: bool = false;
        let arr = match piece_type {
            PieceType::O => [
                [[O, O, O, O], [O, X, X, O], [O, X, X, O], [O, O, O, O]],
                [[O, O, O, O], [O, X, X, O], [O, X, X, O], [O, O, O, O]],
                [[O, O, O, O], [O, X, X, O], [O, X, X, O], [O, O, O, O]],
                [[O, O, O, O], [O, X, X, O], [O, X, X, O], [O, O, O, O]],
            ],
            PieceType::I => [
                [[O, O, X, O], [O, O, X, O], [O, O, X, O], [O, O, X, O]],
                [[O, O, O, O], [O, O, O, O], [X, X, X, X], [O, O, O, O]],
                [[O, X, O, O], [O, X, O, O], [O, X, O, O], [O, X, O, O]],
                [[O, O, O, O], [X, X, X, X], [O, O, O, O], [O, O, O, O]],
            ],
            PieceType::T => [
                [[O, X, O, O], [O, X, X, O], [O, X, O, O], [O, O, O, O]],
                [[O, O, O, O], [X, X, X, O], [O, X, O, O], [O, O, O, O]],
                [[O, X, O, O], [X, X, O, O], [O, X, O, O], [O, O, O, O]],
                [[O, X, O, O], [X, X, X, O], [O, O, O, O], [O, O, O, O]],
            ],
            PieceType::L => [
                [[O, X, O, O], [O, X, O, O], [O, X, X, O], [O, O, O, O]],
                [[O, O, O, O], [X, X, X, O], [X, O, O, O], [O, O, O, O]],
                [[X, X, O, O], [O, X, O, O], [O, X, O, O], [O, O, O, O]],
                [[O, O, X, O], [X, X, X, O], [O, O, O, O], [O, O, O, O]],
            ],
            PieceType::J => [
                [[O, X, X, O], [O, X, O, O], [O, X, O, O], [O, O, O, O]],
                [[O, O, O, O], [X, X, X, O], [O, O, X, O], [O, O, O, O]],
                [[O, X, O, O], [O, X, O, O], [X, X, O, O], [O, O, O, O]],
                [[X, O, O, O], [X, X, X, O], [O, O, O, O], [O, O, O, O]],
            ],
            PieceType::S => [
                [[O, X, O, O], [O, X, X, O], [O, O, X, O], [O, O, O, O]],
                [[O, O, O, O], [O, X, X, O], [X, X, O, O], [O, O, O, O]],
                [[X, O, O, O], [X, X, O, O], [O, X, O, O], [O, O, O, O]],
                [[O, X, X, O], [X, X, O, O], [O, O, O, O], [O, O, O, O]],
            ],
            PieceType::Z => [
                [[O, O, X, O], [O, X, X, O], [O, X, O, O], [O, O, O, O]],
                [[O, O, O, O], [X, X, O, O], [O, X, X, O], [O, O, O, O]],
                [[O, X, O, O], [X, X, O, O], [X, O, O, O], [O, O, O, O]],
                [[X, X, O, O], [O, X, X, O], [O, O, O, O], [O, O, O, O]],
            ],
        };
        arr[rotation as usize]
    }

    /// u16 bitmask of each shape, if shifting out of bounds, the shape will be cut-off
    #[inline]
    pub fn bit_shape(piece_type: PieceType, rotation: i8, x: i8) -> [u16; 4] {
        let arr = match piece_type {
            PieceType::O => [[0, 6, 6, 0], [0, 6, 6, 0], [0, 6, 6, 0], [0, 6, 6, 0]],
            PieceType::I => [[0, 0, 15, 0], [4, 4, 4, 4], [0, 15, 0, 0], [2, 2, 2, 2]],
            PieceType::T => [[0, 7, 2, 0], [2, 6, 2, 0], [2, 7, 0, 0], [2, 3, 2, 0]],
            PieceType::L => [[0, 7, 4, 0], [6, 2, 2, 0], [1, 7, 0, 0], [2, 2, 3, 0]],
            PieceType::J => [[0, 7, 1, 0], [2, 2, 6, 0], [4, 7, 0, 0], [3, 2, 2, 0]],
            PieceType::S => [[0, 3, 6, 0], [4, 6, 2, 0], [3, 6, 0, 0], [2, 3, 1, 0]],
            PieceType::Z => [[0, 6, 3, 0], [2, 6, 4, 0], [6, 3, 0, 0], [1, 3, 2, 0]],
        };
        let mut bits = arr[rotation as usize];
        if x < 0 {
            for i in 0..4 {
                bits[i] >>= -x;
            }
        } else {
            for i in 0..4 {
                bits[i] <<= x;
            }
        }
        bits
    }

    /// Number of empty squares between bottom and bottom-most block in each
    /// column, or -1 if that column is empty
    pub fn height_map(piece_type: PieceType, rotation: i8) -> [i8; 4] {
        let arr = match piece_type {
            PieceType::O => [
                [-1, 1, 1, -1],
                [-1, 1, 1, -1],
                [-1, 1, 1, -1],
                [-1, 1, 1, -1],
            ],
            PieceType::I => [[2, 2, 2, 2], [-1, -1, 0, -1], [1, 1, 1, 1], [-1, 0, -1, -1]],
            PieceType::T => [[1, 1, 1, -1], [-1, 0, 1, -1], [1, 0, 1, -1], [1, 0, -1, -1]],
            PieceType::L => [[1, 1, 1, -1], [-1, 0, 0, -1], [0, 1, 1, -1], [2, 0, -1, -1]],
            PieceType::J => [[1, 1, 1, -1], [-1, 0, 2, -1], [1, 1, 0, -1], [0, 0, -1, -1]],
            PieceType::S => [[1, 1, 2, -1], [-1, 1, 0, -1], [0, 0, 1, -1], [1, 0, -1, -1]],
            PieceType::Z => [[2, 1, 1, -1], [-1, 0, 1, -1], [1, 0, 0, -1], [0, 1, -1, -1]],
        };
        arr[rotation as usize]
    }

    /// Bounds of location coordinates for each piece
    /// (min x, max x, min y, max y)
    pub fn location_bound(piece_type: PieceType, rotation: i8) -> (i8, i8, i8, i8) {
        let arr = match piece_type {
            PieceType::O => [
                (-1, 7, -1, 21),
                (-1, 7, -1, 21),
                (-1, 7, -1, 21),
                (-1, 7, -1, 21),
            ],
            PieceType::I => [
                (0, 6, -2, 21),
                (-2, 7, 0, 20),
                (0, 6, -1, 22),
                (-1, 8, 0, 20),
            ],
            PieceType::T => [(0, 7, -1, 21), (-1, 7, 0, 21), (0, 7, 0, 22), (0, 8, 0, 21)],
            PieceType::L => [(0, 7, -1, 21), (-1, 7, 0, 21), (0, 7, 0, 22), (0, 8, 0, 21)],
            PieceType::J => [(0, 7, -1, 21), (-1, 7, 0, 21), (0, 7, 0, 22), (0, 8, 0, 21)],
            PieceType::S => [(0, 7, -1, 21), (-1, 7, 0, 21), (0, 7, 0, 22), (0, 8, 0, 21)],
            PieceType::Z => [(0, 7, -1, 21), (-1, 7, 0, 21), (0, 7, 0, 22), (0, 8, 0, 21)],
        };
        arr[rotation as usize]
    }

    /// Possible (x, y) shifts when doing kicks
    pub fn kick_table(
        piece_type: PieceType,
        old_rotation: i8,
        new_rotation: i8,
    ) -> &'static [(i8, i8)] {
        let arr: [[&[(i8, i8)]; 4]; 4] = match piece_type {
            PieceType::O => [
                [&[], &[(0, 0)], &[(0, 0)], &[(0, 0)]],
                [&[(0, 0)], &[], &[(0, 0)], &[(0, 0)]],
                [&[(0, 0)], &[(0, 0)], &[], &[(0, 0)]],
                [&[(0, 0)], &[(0, 0)], &[(0, 0)], &[]],
            ],
            PieceType::I => [
                [
                    &[],
                    &[(0, 0), (-2, 0), (1, 0), (-2, -1), (1, 2)],
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (2, 0), (-1, 2), (2, -1)],
                ],
                [
                    &[(0, 0), (2, 0), (-1, 0), (2, 1), (-1, -2)],
                    &[],
                    &[(0, 0), (-1, 0), (2, 0), (-1, 2), (2, -1)],
                    &[(0, 0)],
                ],
                [
                    &[(0, 0)],
                    &[(0, 0), (1, 0), (-2, 0), (1, -2), (-2, 1)],
                    &[],
                    &[(0, 0), (2, 0), (-1, 0), (2, 1), (-1, -2)],
                ],
                [
                    &[(0, 0), (1, 0), (-2, 0), (1, -2), (-2, 1)],
                    &[(0, 0)],
                    &[(0, 0), (-2, 0), (1, 0), (-2, -1), (1, 2)],
                    &[],
                ],
            ],
            PieceType::T => [
                [
                    &[],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[(0, 0)],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[],
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[(0, 0)],
                ],
                [
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[],
                ],
            ],
            PieceType::L => [
                [
                    &[],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[(0, 0)],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[],
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[(0, 0)],
                ],
                [
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[],
                ],
            ],
            PieceType::J => [
                [
                    &[],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[(0, 0)],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[],
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[(0, 0)],
                ],
                [
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[],
                ],
            ],
            PieceType::S => [
                [
                    &[],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[(0, 0)],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[],
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[(0, 0)],
                ],
                [
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[],
                ],
            ],
            PieceType::Z => [
                [
                    &[],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[(0, 0)],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[],
                    &[(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
                    &[(0, 0)],
                ],
                [
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
                    &[],
                    &[(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
                ],
                [
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[(0, 0)],
                    &[(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
                    &[],
                ],
            ],
        };
        arr[old_rotation as usize][new_rotation as usize]
    }
}
